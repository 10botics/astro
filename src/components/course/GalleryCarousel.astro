---
import { Image } from 'astro:assets';

export interface Props {
  title?: string;
  images: (string | ImageMetadata)[];
  intervalMs?: number;
}

const { title, images, intervalMs = 4000 } = Astro.props;

// Normalize images to ensure proper handling for both string URLs and ImageMetadata objects
const normalizedImages = images.map(img => {
  if (typeof img === 'string') {
    // If it's a string URL, return it as is for static assets
    return { src: img, alt: 'Gallery image', isRemote: true };
  } else if (img && typeof img === 'object' && 'src' in img) {
    // This is an ImageMetadata object from Astro import - use the src property
    // According to Astro docs, ImageMetadata objects have a src property that contains the processed image URL
    return { src: img, alt: 'Gallery image', isRemote: false };
  }
  return null;
}).filter(img => img !== null);

// Debug logging for development
if (import.meta.env.DEV) {
  console.log('GalleryCarousel - Original images:', images);
  console.log('GalleryCarousel - Normalized images:', normalizedImages);
}
---

<div class="gallery-carousel relative" data-interval-ms={intervalMs}>
  {title && (
    <div class="text-center mb-8">
      <h3 class="text-2xl font-bold text-gray-800">{title}</h3>
    </div>
  )}
  
  <div class="relative overflow-hidden">
    {normalizedImages.length > 0 ? (
      <>
        <!-- Carousel Track -->
        <div 
          class="carousel-track flex transition-transform duration-500 ease-in-out"
        >
          {/* Create clones for seamless circular scrolling - clone last few images at beginning */}
          {normalizedImages.length > 3 && normalizedImages.slice(-3).map((img, index) => (
            <div 
              class="carousel-slide flex-shrink-0 w-full lg:w-1/3 md:w-1/2 px-2"
              data-clone="start"
            >
              {img.isRemote ? (
                <img 
                  src={img.src as string} 
                  alt={img.alt}
                  class="w-full h-auto object-contain rounded-lg"
                  loading="lazy"
                  decoding="async"
                />
              ) : (
                <Image 
                  src={img.src as ImageMetadata} 
                  alt={img.alt}
                  class="w-full h-auto object-contain rounded-lg"
                  loading="lazy"
                  decoding="async"
                />
              )}
            </div>
          ))}

          {/* Original images */}
          {normalizedImages.map((img, index) => (
            <div 
              class="carousel-slide flex-shrink-0 w-full lg:w-1/3 md:w-1/2 px-2"
              data-original-index={index}
            >
              {img.isRemote ? (
                <img 
                  src={img.src as string} 
                  alt={img.alt}
                  class="w-full h-auto object-contain rounded-lg"
                  loading="lazy"
                  decoding="async"
                />
              ) : (
                <Image 
                  src={img.src as ImageMetadata} 
                  alt={img.alt}
                  class="w-full h-auto object-contain rounded-lg"
                  loading="lazy"
                  decoding="async"
                />
              )}
            </div>
          ))}

          {/* Create clones for seamless circular scrolling - clone first few images at end */}
          {normalizedImages.length > 3 && normalizedImages.slice(0, 3).map((img, index) => (
            <div 
              class="carousel-slide flex-shrink-0 w-full lg:w-1/3 md:w-1/2 px-2"
              data-clone="end"
            >
              {img.isRemote ? (
                <img 
                  src={img.src as string} 
                  alt={img.alt}
                  class="w-full h-auto object-contain rounded-lg"
                  loading="lazy"
                  decoding="async"
                />
              ) : (
                <Image 
                  src={img.src as ImageMetadata} 
                  alt={img.alt}
                  class="w-full h-auto object-contain rounded-lg"
                  loading="lazy"
                  decoding="async"
                />
              )}
            </div>
          ))}
        </div>

        <!-- Navigation Buttons -->
        <button 
          class="carousel-btn carousel-prev absolute left-2 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white text-gray-800 p-2 rounded-full shadow-lg transition-all duration-200 z-10"
          aria-label="Previous image"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
          </svg>
        </button>
        
        <button 
          class="carousel-btn carousel-next absolute right-2 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white text-gray-800 p-2 rounded-full shadow-lg transition-all duration-200 z-10"
          aria-label="Next image"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
          </svg>
        </button>

        <!-- Dots -->
        <div class="carousel-dots absolute bottom-4 left-1/2 -translate-x-1/2 flex space-x-2 z-10">
          {normalizedImages.map((_, i) => (
            <button 
              class="carousel-dot w-3 h-3 rounded-full bg-white/60 hover:bg-white transition-colors duration-200"
              aria-label={`Go to slide ${i + 1}`}
              data-index={i}
            ></button>
          ))}
        </div>
      </>
    ) : (
      <div class="text-center py-16 text-gray-500">
        <p>No images available</p>
      </div>
    )}
  </div>
</div>

<style>
  .gallery-carousel {
    --per-view: 1;
  }
  
  @media (min-width: 768px) {
    .gallery-carousel {
      --per-view: 2;
    }
  }
  
  @media (min-width: 1024px) {
    .gallery-carousel {
      --per-view: 3;
    }
  }
  
  .carousel-track {
    transform: translateX(0);
  }
</style>

<script>
  class GalleryCarousel {
    private container: HTMLElement;
    private track: HTMLElement;
    private slides: NodeListOf<Element>;
    private originalSlides: NodeListOf<Element>;
    private prevBtn: HTMLElement | null;
    private nextBtn: HTMLElement | null;
    private dots: NodeListOf<Element>;
    private currentIndex: number;
    private perView: number;
    private totalSlides: number;
    private cloneOffset: number;
    private autoplayInterval: ReturnType<typeof setInterval> | null;
    private intervalMs: number;

    constructor(container: HTMLElement) {
      this.container = container;
      this.track = container.querySelector('.carousel-track') as HTMLElement;
      this.slides = container.querySelectorAll('.carousel-slide');
      this.originalSlides = container.querySelectorAll('[data-original-index]');
      this.prevBtn = container.querySelector('.carousel-prev') as HTMLElement | null;
      this.nextBtn = container.querySelector('.carousel-next') as HTMLElement | null;
      this.dots = container.querySelectorAll('.carousel-dot');
      
      this.totalSlides = this.originalSlides.length;
      this.cloneOffset = this.totalSlides > 3 ? 3 : 0; // Number of cloned slides at the beginning
      this.currentIndex = this.cloneOffset; // Start at the first real slide
      this.perView = this.getPerView();
      this.autoplayInterval = null;
      this.intervalMs = parseInt(container.dataset.intervalMs || '4000');
      
      this.init();
    }
    
    getPerView(): number {
      if (window.innerWidth >= 1024) return 3; // lg
      if (window.innerWidth >= 768) return 2;  // md
      return 1; // sm
    }
    
    updatePerView() {
      const newPerView = this.getPerView();
      if (newPerView !== this.perView) {
        this.perView = newPerView;
        // Clamp current index to valid range
        this.currentIndex = Math.min(this.currentIndex, this.totalSlides - 1);
        this.updateTrack();
        this.updateDots();
      }
    }
    
    init() {
      this.bindEvents();
      this.startAutoplay();
      this.updateDots();
      this.updateButtons();
      this.updateTrack();
    }
    
    bindEvents() {
      this.prevBtn?.addEventListener('click', () => this.prev());
      this.nextBtn?.addEventListener('click', () => this.next());
      
      this.dots.forEach((dot: Element, index: number) => {
        dot.addEventListener('click', () => this.goToSlide(index));
      });
      
      // Pause autoplay on hover
      this.container.addEventListener('mouseenter', () => this.pauseAutoplay());
      this.container.addEventListener('mouseleave', () => this.resumeAutoplay());
      
      // Pause autoplay on interaction
      this.container.addEventListener('click', () => this.pauseAutoplay());
      
      // Handle responsive behavior
      window.addEventListener('resize', () => this.updatePerView());
      
      // Keyboard navigation
      document.addEventListener('keydown', (e) => {
        if (this.container.contains(document.activeElement)) {
          if (e.key === 'ArrowLeft') this.prev();
          if (e.key === 'ArrowRight') this.next();
        }
      });
    }
    
    updateTrack() {
  const imageWidth = 100 / this.perView; // Width of one image in the current view
  const translateX = -(this.currentIndex * imageWidth);
  this.track.style.transform = `translateX(${translateX}%)`;
    }
    
    prev() {
      this.currentIndex--;
      
      // Check if we need to wrap around
      if (this.cloneOffset > 0 && this.currentIndex < this.cloneOffset) {
        // We're before the first real slide, jump to the end without animation
        this.track.style.transition = 'none';
        this.currentIndex = this.cloneOffset + this.totalSlides - 1;
        this.updateTrack();
        // Re-enable animation after a brief delay
        setTimeout(() => {
          this.track.style.transition = 'transform 500ms ease-in-out';
        }, 10);
      } else if (this.cloneOffset === 0 && this.currentIndex < 0) {
        this.currentIndex = this.totalSlides - 1;
      }
      
      this.updateTrack();
      this.updateDots();
      this.updateButtons();
      this.restartAutoplay();
    }
    
    next() {
      this.currentIndex++;
      
      // Check if we need to wrap around
      if (this.cloneOffset > 0 && this.currentIndex >= this.cloneOffset + this.totalSlides) {
        // We're past the last real slide, jump to the beginning without animation
        this.track.style.transition = 'none';
        this.currentIndex = this.cloneOffset;
        this.updateTrack();
        // Re-enable animation after a brief delay
        setTimeout(() => {
          this.track.style.transition = 'transform 500ms ease-in-out';
        }, 10);
      } else if (this.cloneOffset === 0 && this.currentIndex >= this.totalSlides) {
        this.currentIndex = 0;
      }
      
      this.updateTrack();
      this.updateDots();
      this.updateButtons();
      this.restartAutoplay();
    }
    
    goToSlide(slideIndex: number) {
      // Convert dot index to actual slide index (accounting for clones)
      this.currentIndex = this.cloneOffset + slideIndex;
      this.updateTrack();
      this.updateDots();
      this.updateButtons();
      this.restartAutoplay();
    }
    
    updateDots() {
      // Calculate which original slide we're currently viewing
      const activeOriginalIndex = this.currentIndex - this.cloneOffset;
      
      this.dots.forEach((dot: Element, index: number) => {
        if (index === activeOriginalIndex) {
          dot.classList.add('bg-white');
          dot.classList.remove('bg-white/60');
          dot.setAttribute('aria-selected', 'true');
        } else {
          dot.classList.remove('bg-white');
          dot.classList.add('bg-white/60');
          dot.setAttribute('aria-selected', 'false');
        }
      });
    }
    
    updateButtons() {
      // Buttons are always enabled for circular navigation
      this.prevBtn?.setAttribute('aria-disabled', 'false');
      this.nextBtn?.setAttribute('aria-disabled', 'false');
    }
    
    startAutoplay() {
      this.autoplayInterval = setInterval(() => {
        this.next();
      }, this.intervalMs);
    }
    
    pauseAutoplay() {
      if (this.autoplayInterval) {
        clearInterval(this.autoplayInterval);
        this.autoplayInterval = null;
      }
    }
    
    resumeAutoplay() {
      setTimeout(() => {
        this.startAutoplay();
      }, 1000);
    }
    
    restartAutoplay() {
      this.pauseAutoplay();
      this.startAutoplay();
    }
  }
  
  // Initialize all carousels
  document.addEventListener('DOMContentLoaded', () => {
    const carousels = document.querySelectorAll('.gallery-carousel');
    carousels.forEach(carousel => {
      new GalleryCarousel(carousel as HTMLElement);
    });
  });
</script> 